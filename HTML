!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Cherrak Infinity — WebAuthn Demo</title>
<style>
  body{font-family:Arial, sans-serif;padding:20px;background:#05071a;color:#fff}
  .box{max-width:800px;margin:18px auto;padding:20px;border-radius:10px;background:#07102a}
  label{display:block;margin:8px 0}
  input{padding:8px;border-radius:6px;border:1px solid #334}
  button{padding:8px 12px;border-radius:6px;background:#00d4ff;border:none;color:#012;cursor:pointer}
  pre{white-space:pre-wrap;background:#021022;padding:12px;border-radius:6px}
</style>
</head>
<body>
  <div class="box">
    <h2>Cherrak Infinity — WebAuthn Demo</h2>
    <p>ملاحظة: يجب تشغيل الخادم (server.js) وفتحه على <code>http://localhost:3000</code> أو عنوان HTTPS قبل التجربة.</p>

    <div>
      <label>اسم المستخدم (username):</label>
      <input id="username" value="cherrakhouari" />
    </div>

    <div style="margin-top:12px">
      <button id="regOptions">طلب خيارات تسجيل (Register options)</button>
      <button id="regVerify">إرسال استجابة التسجيل (Verify register)</button>
    </div>

    <div style="margin-top:12px">
      <button id="authOptions">طلب خيارات تسجيل دخول (Auth options)</button>
      <button id="authVerify">إرسال استجابة المصادقة (Verify login)</button>
    </div>

    <h4>نتيجة / لوج</h4>
    <pre id="log">جاهز</pre>
  </div>

<script>
const serverOrigin = window.location.origin.includes('file:') ? 'http://localhost:3000' : window.location.origin;
// If server is on other host, change:
// const serverOrigin = 'http://localhost:3000';

function log(v){ document.getElementById('log').textContent = JSON.stringify(v, null, 2); }

async function postJSON(url, body){
  const res = await fetch(serverOrigin + url, {
    method: 'POST',
    headers: {'Content-Type':'application/json'},
    credentials:'include',
    body: JSON.stringify(body)
  });
  return res.json();
}

function bufferToBase64(buf){
  return btoa(String.fromCharCode(...new Uint8Array(buf)));
}
function base64ToBuffer(base64){
  return Uint8Array.from(atob(base64), c => c.charCodeAt(0));
}

document.getElementById('regOptions').addEventListener('click', async ()=>{
  const username = document.getElementById('username').value || 'demo';
  const opts = await postJSON('/register/options', { username, displayName: username });
  log({ step:'registerOptions', opts });
  // convert challenge/ids to proper ArrayBuffers if necessary when calling navigator.credentials.create
  // Keep options for client-side verification step
  window._registerOptions = opts;
});

document.getElementById('regVerify').addEventListener('click', async ()=>{
  if(!window._registerOptions) return alert('طلب خيارات التسجيل أولاً');
  // Call browser create()
  try {
    // adapt options: base64url -> ArrayBuffers
    const publicKey = JSON.parse(JSON.stringify(window._registerOptions));
    publicKey.challenge = base64ToBuffer(publicKey.challenge);
    if(publicKey.user && publicKey.user.id) publicKey.user.id = base64ToBuffer(publicKey.user.id);
    if(publicKey.excludeCredentials){
      publicKey.excludeCredentials = publicKey.excludeCredentials.map(c=> ({ ...c, id: base64ToBuffer(c.id) }) );
    }
    const cred = await navigator.credentials.create({ publicKey });
    // Prepare data to send to server
    const response = {
      id: cred.id,
      rawId: bufferToBase64(cred.rawId),
      response: {
        attestationObject: bufferToBase64(cred.response.attestationObject),
        clientDataJSON: bufferToBase64(cred.response.clientDataJSON)
      },
      type: cred.type
    };
    const verify = await postJSON('/register/verify', response);
    log({ step:'registerVerify', verify });
  } catch (e) {
    log({ error: String(e) });
  }
});

document.getElementById('authOptions').addEventListener('click', async ()=>{
  const username = document.getElementById('username').value || 'demo';
  const opts = await postJSON('/login/options', { username });
  window._authOptions = opts;
  log({ step:'authOptions', opts });
});

document.getElementById('authVerify').addEventListener('click', async ()=>{
  if(!window._authOptions) return alert('طلب خيارات المصادقة أولاً');
  try {
    const publicKey = JSON.parse(JSON.stringify(window._authOptions));
    publicKey.challenge = base64ToBuffer(publicKey.challenge);
    if(publicKey.allowCredentials) publicKey.allowCredentials = publicKey.allowCredentials.map(c=> ({ ...c, id: base64ToBuffer(c.id) }) );
    const assertion = await navigator.credentials.get({ publicKey });
    const data = {
      id: assertion.id,
      rawId: bufferToBase64(assertion.rawId),
      response: {
        authenticatorData: bufferToBase64(assertion.response.authenticatorData),
        clientDataJSON: bufferToBase64(assertion.response.clientDataJSON),
        signature: bufferToBase64(assertion.response.signature),
        userHandle: assertion.response.userHandle ? bufferToBase64(assertion.response.userHandle) : null
      },
      type: assertion.type
    };
    const verify = await postJSON('/login/verify', data);
    log({ step:'authVerify', verify });
  } catch (e) {
    log({ error: String(e) });
  }
});
</script>
</body>
</html>
